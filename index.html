<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shadow Painter - Interactive Art Tool</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #1e1e2e 0%, #2d1b3d 100%);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            user-select: none;
        }

        #canvas {
            display: block;
            cursor: crosshair;
            background: #0a0a0a;
        }

        #controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 10;
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
            transform: translateY(-2px);
        }

        .btn:focus {
            outline: 2px solid rgba(255, 255, 255, 0.6);
            outline-offset: 2px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn:disabled:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
            transform: none;
        }

        #settingsBtn {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 10;
        }

        #info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 14px;
            z-index: 10;
        }

        /* Settings Panel Styles */
        #settingsPanel {
            position: fixed;
            right: -380px;
            top: 0;
            width: 380px;
            height: 100%;
            background: rgba(30, 30, 46, 0.95);
            backdrop-filter: blur(10px);
            border-left: 2px solid rgba(255, 255, 255, 0.1);
            transition: right 0.3s ease;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: -10px 0 30px rgba(0, 0, 0, 0.5);
        }

        #settingsPanel.open {
            right: 0;
        }

        .settings-header {
            padding: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .settings-header h2 {
            color: white;
            font-size: 18px;
            margin: 0;
        }

        .mode-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.15);
        }

        .mode-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.3);
        }

        .mode-name {
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
            font-weight: 600;
        }

        .mode-desc {
            color: rgba(255, 255, 255, 0.6);
            font-size: 11px;
            margin-left: auto;
        }

        .settings-close {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            font-size: 24px;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.2s ease;
        }

        .settings-close:hover {
            color: white;
        }

        .settings-close:focus {
            outline: 2px solid rgba(255, 255, 255, 0.6);
            outline-offset: 2px;
        }

        .settings-content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .settings-section {
            margin-bottom: 24px;
            padding: 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .settings-section h3 {
            color: rgba(255, 255, 255, 0.9);
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            margin-top: 0;
        }

        .control-group {
            margin-bottom: 16px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .control-group label {
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .control-value {
            color: rgba(255, 255, 255, 0.9);
            font-weight: bold;
            font-size: 12px;
        }

        input[type="color"] {
            width: 100%;
            height: 36px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            cursor: pointer;
            transition: border-color 0.2s ease;
        }

        input[type="color"]:hover {
            border-color: rgba(255, 255, 255, 0.4);
        }

        input[type="color"]:focus {
            outline: 2px solid rgba(255, 255, 255, 0.6);
            outline-offset: 2px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: white;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            border: none;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        input[type="range"]::-moz-range-thumb:hover {
            background: white;
        }

        input[type="range"]:focus {
            background: rgba(255, 255, 255, 0.15);
        }

        .button-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .toggle-btn {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.7);
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .toggle-btn:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .toggle-btn:focus {
            outline: 2px solid rgba(255, 255, 255, 0.6);
            outline-offset: 2px;
        }

        .toggle-btn.active {
            background: rgba(255, 255, 255, 0.25);
            border-color: rgba(255, 255, 255, 0.5);
            color: white;
            box-shadow: 0 0 12px rgba(255, 255, 255, 0.2);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: rgba(255, 255, 255, 0.8);
        }

        input[type="checkbox"]:focus {
            outline: 2px solid rgba(255, 255, 255, 0.6);
            outline-offset: 2px;
        }

        .checkbox-group label {
            cursor: pointer;
            color: rgba(255, 255, 255, 0.7);
            font-size: 13px;
            flex: 1;
            margin: 0;
        }

        .settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            z-index: 999;
        }

        .settings-overlay.open {
            opacity: 1;
            pointer-events: auto;
        }

        /* Keyboard Hints Overlay */
        #keyboardHints {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(30, 30, 46, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            padding: 16px;
            color: rgba(255, 255, 255, 0.8);
            font-size: 12px;
            z-index: 50;
            max-width: 200px;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
        }

        #keyboardHints.show {
            opacity: 1;
            pointer-events: auto;
        }

        .hint-item {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            align-items: center;
        }

        .hint-item:last-child {
            margin-bottom: 0;
        }

        .hint-key {
            background: rgba(255, 255, 255, 0.15);
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 600;
            min-width: 24px;
            text-align: center;
            white-space: nowrap;
            color: white;
        }

        .hint-desc {
            color: rgba(255, 255, 255, 0.7);
            flex: 1;
        }

        .clear-button-group {
            display: flex;
            gap: 8px;
        }

        #clearSettingsBtn {
            flex: 1;
            padding: 10px 12px;
            background: rgba(255, 107, 107, 0.15);
            border: 1px solid rgba(255, 107, 107, 0.3);
            color: rgba(255, 107, 107, 0.9);
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        #clearSettingsBtn:hover {
            background: rgba(255, 107, 107, 0.25);
            border-color: rgba(255, 107, 107, 0.5);
        }

        #clearSettingsBtn:focus {
            outline: 2px solid rgba(255, 107, 107, 0.6);
            outline-offset: 2px;
        }

        @media (max-width: 768px) {
            #controls {
                top: 10px;
                left: 10px;
                gap: 6px;
            }

            #settingsBtn {
                top: 10px;
                right: 10px;
            }
            
            .btn {
                padding: 8px 16px;
                font-size: 12px;
            }
            
            #info {
                bottom: 10px;
                left: 10px;
                font-size: 12px;
            }

            #settingsPanel {
                width: 100%;
                right: -100%;
            }

            .settings-content {
                padding: 16px;
            }

            .button-group {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            .btn {
                padding: 6px 12px;
                font-size: 11px;
            }

            .settings-section {
                padding: 12px;
                margin-bottom: 16px;
            }

            .settings-header {
                padding: 16px;
            }

            .settings-header h2 {
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="controls">
        <button class="btn" id="saveBtn">Save Artwork</button>
        <button class="btn" id="clearBtn">Clear Canvas</button>
    </div>

    <button class="btn" id="settingsBtn">‚öôÔ∏è Settings</button>

    <div id="settingsPanel" class="settings-panel">
        <div class="settings-header">
            <div>
                <h2>Settings</h2>
                <div class="mode-indicator">
                    <div class="mode-color" id="modeColor"></div>
                    <div class="mode-name" id="modeName">Glow</div>
                    <div class="mode-desc" id="modeDesc">Soft ambient glows</div>
                </div>
            </div>
            <button class="settings-close" aria-label="Close settings">‚úï</button>
        </div>
        <div class="settings-content">
            <!-- Visual Controls Section -->
            <div class="settings-section">
                <h3>Visual</h3>
                
                <div class="control-group">
                    <label>
                        Shadow Color
                        <span class="control-value" id="shadowColorValue">#ff6b6b</span>
                    </label>
                    <input type="color" id="shadowColor" value="#ff6b6b" aria-label="Shadow color picker">
                </div>

                <div class="control-group">
                    <label>
                        Gradient Primary
                        <span class="control-value" id="gradientPrimaryValue">#ff6b6b</span>
                    </label>
                    <input type="color" id="gradientPrimary" value="#ff6b6b" aria-label="Primary gradient color picker">
                </div>

                <div class="control-group">
                    <label>
                        Particle Color
                        <span class="control-value" id="particleColorValue">#4ecdc4</span>
                    </label>
                    <input type="color" id="particleColor" value="#4ecdc4" aria-label="Particle color picker">
                </div>

                <div class="control-group">
                    <label>Background Theme</label>
                    <div class="button-group">
                        <button class="toggle-btn active" data-theme="dark" aria-pressed="true">Dark</button>
                        <button class="toggle-btn" data-theme="light" aria-pressed="false">Light</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Background Pattern</label>
                    <div class="button-group" style="grid-template-columns: 1fr 1fr 1fr;">
                        <button class="toggle-btn active" data-pattern="auto" aria-pressed="true" title="Follows effect mode">Auto</button>
                        <button class="toggle-btn" data-pattern="electric-grid" aria-pressed="false" title="Electric grid on dark">Grid</button>
                        <button class="toggle-btn" data-pattern="soft-dots" aria-pressed="false" title="Soft dot pattern">Dots</button>
                        <button class="toggle-btn" data-pattern="starfield" aria-pressed="false" title="Deep space starfield">Space</button>
                        <button class="toggle-btn" data-pattern="paper-texture" aria-pressed="false" title="Paper texture">Paper</button>
                        <button class="toggle-btn" data-pattern="clean" aria-pressed="false" title="Clean minimal">Clean</button>
                    </div>
                </div>
            </div>

            <!-- Interaction Controls Section -->
            <div class="settings-section">
                <h3>Interaction</h3>

                <div class="control-group">
                    <label>
                        Brush Size
                        <span class="control-value" id="brushSizeValue">5</span>
                    </label>
                    <input type="range" id="brushSize" min="1" max="20" value="5" aria-label="Brush size slider">
                </div>

                <div class="control-group">
                    <label>
                        Brush Intensity
                        <span class="control-value" id="brushIntensityValue">1.0</span>
                    </label>
                    <input type="range" id="brushIntensity" min="0.1" max="2" step="0.1" value="1.0" aria-label="Brush intensity slider">
                </div>

                <div class="control-group">
                    <label>Speed Sensitivity</label>
                    <input type="range" id="speedSensitivity" min="0.5" max="2" step="0.1" value="1" aria-label="Speed sensitivity slider">
                    <span class="control-value" id="speedSensitivityValue">1.0x</span>
                </div>
            </div>

            <!-- Artistic Controls Section -->
            <div class="settings-section">
                <h3>Artistic</h3>

                <div class="control-group">
                    <label>
                        Blur
                        <span class="control-value" id="blurValue">10</span>
                    </label>
                    <input type="range" id="blur" min="0" max="30" value="10" aria-label="Blur slider">
                </div>

                <div class="control-group">
                    <label>
                        Motion
                        <span class="control-value" id="motionValue">0.98</span>
                    </label>
                    <input type="range" id="motion" min="0.8" max="0.99" step="0.01" value="0.98" aria-label="Motion slider">
                </div>

                <div class="control-group">
                    <label>
                        Opacity
                        <span class="control-value" id="opacityValue">0.8</span>
                    </label>
                    <input type="range" id="opacity" min="0.1" max="1" step="0.1" value="0.8" aria-label="Opacity slider">
                </div>

                <div class="control-group">
                    <label>
                        Persistence
                        <span class="control-value" id="persistenceValue">0.05</span>
                    </label>
                    <input type="range" id="persistence" min="0.01" max="0.2" step="0.01" value="0.05" aria-label="Persistence slider">
                </div>

                <div class="control-group">
                    <label>Effect Mode
                        <span class="control-value" id="modeDescription">Soft ambient glows and light</span>
                    </label>
                    <div class="button-group" style="grid-template-columns: 1fr 1fr 1fr;">
                        <button class="toggle-btn active" data-effect="glow" aria-pressed="true" title="Soft ambient glows and light">Glow</button>
                        <button class="toggle-btn" data-effect="neon" aria-pressed="false" title="Vibrant glows with electric colors">Neon</button>
                        <button class="toggle-btn" data-effect="lightTrails" aria-pressed="false" title="Motion blur with ethereal trails">Trails</button>
                        <button class="toggle-btn" data-effect="inkEffect" aria-pressed="false" title="Desaturated spreads and smears">Ink</button>
                        <button class="toggle-btn" data-effect="classicShadow" aria-pressed="false" title="Traditional dark shadows">Shadow</button>
                    </div>
                </div>

                <div class="control-group">
                    <label>Particle Shape</label>
                    <div class="button-group">
                        <button class="toggle-btn active" data-shape="circle" aria-pressed="true">Circle</button>
                        <button class="toggle-btn" data-shape="square" aria-pressed="false">Square</button>
                    </div>
                </div>
            </div>

            <!-- Performance Controls Section -->
            <div class="settings-section">
                <h3>Performance</h3>

                <div class="control-group checkbox-group">
                    <input type="checkbox" id="enableParticles" checked aria-label="Enable particles">
                    <label for="enableParticles">Enable Particles</label>
                </div>

                <div class="control-group checkbox-group">
                    <input type="checkbox" id="enableShadows" checked aria-label="Enable shadows">
                    <label for="enableShadows">Enable Shadows</label>
                </div>

                <div class="control-group checkbox-group">
                    <input type="checkbox" id="enableGlow" checked aria-label="Enable cursor glow">
                    <label for="enableGlow">Enable Cursor Glow</label>
                </div>

                <div class="control-group">
                    <label>
                        Max Particles
                        <span class="control-value" id="maxParticlesValue">200</span>
                    </label>
                    <input type="range" id="maxParticles" min="50" max="500" step="50" value="200" aria-label="Maximum particles slider">
                </div>
            </div>

            <!-- History & Canvas Controls Section -->
            <div class="settings-section">
                <h3>Canvas</h3>

                <div class="control-group">
                    <label>History Depth</label>
                    <div class="button-group">
                        <button class="btn" id="undoBtn" title="Undo last action (Z)" style="flex: 1; padding: 8px 12px; margin: 0; font-size: 12px;">‚Ü∂ Undo</button>
                        <button class="btn" id="redoBtn" title="Redo last action (R)" style="flex: 1; padding: 8px 12px; margin: 0; font-size: 12px;">‚Ü∑ Redo</button>
                    </div>
                </div>

                <div class="control-group">
                    <button id="clearSettingsBtn" title="Clear canvas (C)">üóëÔ∏è Clear Canvas</button>
                </div>
            </div>
        </div>
    </div>

    <div class="settings-overlay" id="settingsOverlay"></div>
    
    <div id="keyboardHints">
        <div class="hint-item">
            <span class="hint-key">S</span>
            <span class="hint-desc">Save</span>
        </div>
        <div class="hint-item">
            <span class="hint-key">C</span>
            <span class="hint-desc">Clear</span>
        </div>
        <div class="hint-item">
            <span class="hint-key">Z</span>
            <span class="hint-desc">Undo</span>
        </div>
        <div class="hint-item">
            <span class="hint-key">R</span>
            <span class="hint-desc">Redo</span>
        </div>
        <div class="hint-item">
            <span class="hint-key">+/-</span>
            <span class="hint-desc">Brush Size</span>
        </div>
        <div class="hint-item">
            <span class="hint-key">?</span>
            <span class="hint-desc">Toggle Hints</span>
        </div>
    </div>
    
    <div id="info">
        <div>Move your mouse to create art</div>
        <div id="fps">FPS: 60</div>
    </div>

    <script>
        // Utility debounce function
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        class ShadowPainter {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.mouse = { x: 0, y: 0, lastX: 0, lastY: 0, isMoving: false };
                this.particles = [];
                this.shadows = [];
                this.gradientStops = [];
                this.lastTime = 0;
                this.fps = 60;
                this.fpsUpdateTime = 0;
                
                // History system
                this.history = [];
                this.historyIndex = -1;
                this.maxHistoryStates = 30;
                
                this.config = {
                    visual: {
                        shadowColor: '#ff6b6b',
                        gradientPrimary: '#ff6b6b',
                        particleColor: '#4ecdc4',
                        backgroundTheme: 'dark',
                        backgroundPattern: 'auto'
                    },
                    interaction: {
                        brushSize: 5,
                        brushIntensity: 1.0,
                        speedSensitivity: 1.0
                    },
                    artistic: {
                        blur: 10,
                        motion: 0.98,
                        opacity: 0.8,
                        persistence: 0.05,
                        effectMode: 'glow',
                        particleShape: 'circle'
                    },
                    performance: {
                        enableParticles: true,
                        enableShadows: true,
                        enableGlow: true,
                        maxParticles: 200
                    }
                };
                
                this.init();
            }

            init() {
                this.resizeCanvas();
                this.setupEventListeners();
                this.setupControls();
                this.setupSettingsPanel();
                
                // Initialize current mode
                this.switchEffectMode(this.config.artistic.effectMode);
                
                this.animate();
                
                this.gradientStops = [
                    { color: '#ff6b6b', alpha: 0.8 },
                    { color: '#4ecdc4', alpha: 0.8 },
                    { color: '#45b7d1', alpha: 0.8 },
                    { color: '#96ceb4', alpha: 0.8 },
                    { color: '#ffeaa7', alpha: 0.8 },
                    { color: '#dda0dd', alpha: 0.8 }
                ];

                // Effect Modes Registry
                this.modeRegistry = {
                    neon: {
                        name: 'Neon',
                        description: 'Vibrant glows with electric colors',
                        palette: [
                            { color: '#ff0080', alpha: 1.0 },
                            { color: '#00ff80', alpha: 1.0 },
                            { color: '#8000ff', alpha: 1.0 },
                            { color: '#ffff00', alpha: 1.0 },
                            { color: '#00ffff', alpha: 1.0 },
                            { color: '#ff4000', alpha: 1.0 }
                        ],
                        blendingMode: 'screen',
                        particleBehavior: {
                            glowIntensity: 1.5,
                            spreadFactor: 0.8,
                            lifeMultiplier: 1.2,
                            sizeMultiplier: 1.3
                        },
                        shadowBehavior: {
                            blurMultiplier: 2.0,
                            opacityMultiplier: 1.4,
                            radiusMultiplier: 1.5,
                            colorIntensity: 1.8
                        },
                        backgroundTheme: 'dark',
                        backgroundPattern: 'electric-grid',
                        globalComposite: 'screen'
                    },
                    glow: {
                        name: 'Glow',
                        description: 'Soft ambient glows and light',
                        palette: [
                            { color: '#ffb3ba', alpha: 0.9 },
                            { color: '#b3d9ff', alpha: 0.9 },
                            { color: '#b3ffb3', alpha: 0.9 },
                            { color: '#ffffb3', alpha: 0.9 },
                            { color: '#d9b3ff', alpha: 0.9 },
                            { color: '#ffb3d9', alpha: 0.9 }
                        ],
                        blendingMode: 'source-over',
                        particleBehavior: {
                            glowIntensity: 1.0,
                            spreadFactor: 1.0,
                            lifeMultiplier: 1.0,
                            sizeMultiplier: 1.0
                        },
                        shadowBehavior: {
                            blurMultiplier: 1.0,
                            opacityMultiplier: 1.0,
                            radiusMultiplier: 1.0,
                            colorIntensity: 1.0
                        },
                        backgroundTheme: 'dark',
                        backgroundPattern: 'soft-dots',
                        globalComposite: 'source-over'
                    },
                    lightTrails: {
                        name: 'Light Trails',
                        description: 'Motion blur with ethereal trails',
                        palette: [
                            { color: '#ffffff', alpha: 0.7 },
                            { color: '#e6f3ff', alpha: 0.7 },
                            { color: '#cce6ff', alpha: 0.7 },
                            { color: '#b3d9ff', alpha: 0.7 },
                            { color: '#99ccff', alpha: 0.7 },
                            { color: '#80bfff', alpha: 0.7 }
                        ],
                        blendingMode: 'lighter',
                        particleBehavior: {
                            glowIntensity: 0.8,
                            spreadFactor: 2.0,
                            lifeMultiplier: 2.5,
                            sizeMultiplier: 0.7
                        },
                        shadowBehavior: {
                            blurMultiplier: 3.0,
                            opacityMultiplier: 0.6,
                            radiusMultiplier: 2.0,
                            colorIntensity: 0.8
                        },
                        backgroundTheme: 'dark',
                        backgroundPattern: 'starfield',
                        globalComposite: 'lighter'
                    },
                    inkEffect: {
                        name: 'Ink',
                        description: 'Desaturated spreads and smears',
                        palette: [
                            { color: '#4a4a4a', alpha: 0.8 },
                            { color: '#6a6a6a', alpha: 0.8 },
                            { color: '#8a8a8a', alpha: 0.8 },
                            { color: '#3a3a3a', alpha: 0.8 },
                            { color: '#5a5a5a', alpha: 0.8 },
                            { color: '#7a7a7a', alpha: 0.8 }
                        ],
                        blendingMode: 'multiply',
                        particleBehavior: {
                            glowIntensity: 0.3,
                            spreadFactor: 2.5,
                            lifeMultiplier: 1.8,
                            sizeMultiplier: 1.6
                        },
                        shadowBehavior: {
                            blurMultiplier: 1.5,
                            opacityMultiplier: 1.2,
                            radiusMultiplier: 1.8,
                            colorIntensity: 0.6
                        },
                        backgroundTheme: 'light',
                        backgroundPattern: 'paper-texture',
                        globalComposite: 'multiply'
                    },
                    classicShadow: {
                        name: 'Classic Shadow',
                        description: 'Traditional dark shadows',
                        palette: [
                            { color: '#2c1810', alpha: 0.9 },
                            { color: '#4a2c17', alpha: 0.9 },
                            { color: '#1a0e08', alpha: 0.9 },
                            { color: '#3d2514', alpha: 0.9 },
                            { color: '#5d3a1a', alpha: 0.9 },
                            { color: '#1c1209', alpha: 0.9 }
                        ],
                        blendingMode: 'multiply',
                        particleBehavior: {
                            glowIntensity: 0.2,
                            spreadFactor: 1.2,
                            lifeMultiplier: 0.8,
                            sizeMultiplier: 1.0
                        },
                        shadowBehavior: {
                            blurMultiplier: 0.8,
                            opacityMultiplier: 1.5,
                            radiusMultiplier: 0.9,
                            colorIntensity: 0.4
                        },
                        backgroundTheme: 'light',
                        backgroundPattern: 'clean',
                        globalComposite: 'source-over'
                    }
                };

                this.currentMode = this.config.artistic.effectMode;
            }

            // History management methods
            captureState() {
                // Capture current canvas state
                const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                
                // Remove any states after current position (for redo functionality)
                this.history = this.history.slice(0, this.historyIndex + 1);
                
                // Add new state
                this.history.push(imageData);
                this.historyIndex = this.history.length - 1;
                
                // Maintain bounded history
                if (this.history.length > this.maxHistoryStates) {
                    this.history.shift();
                    this.historyIndex--;
                }
                
                this.updateHistoryButtonStates();
            }

            undo() {
                if (this.historyIndex > 0) {
                    this.historyIndex--;
                    this.restoreState(this.history[this.historyIndex]);
                    this.updateHistoryButtonStates();
                }
            }

            redo() {
                if (this.historyIndex < this.history.length - 1) {
                    this.historyIndex++;
                    this.restoreState(this.history[this.historyIndex]);
                    this.updateHistoryButtonStates();
                }
            }

            restoreState(imageData) {
                this.ctx.putImageData(imageData, 0, 0);
                this.particles = [];
                this.shadows = [];
            }

            updateHistoryButtonStates() {
                const undoBtn = document.getElementById('undoBtn');
                const redoBtn = document.getElementById('redoBtn');
                
                if (undoBtn) {
                    undoBtn.disabled = this.historyIndex <= 0;
                    undoBtn.style.opacity = this.historyIndex <= 0 ? '0.5' : '1';
                }
                
                if (redoBtn) {
                    redoBtn.disabled = this.historyIndex >= this.history.length - 1;
                    redoBtn.style.opacity = this.historyIndex >= this.history.length - 1 ? '0.5' : '1';
                }
            }

            // Palette interpolation helpers
            interpolateColor(color1, color2, factor) {
                const rgb1 = this.hexToRgb(color1);
                const rgb2 = this.hexToRgb(color2);
                
                const r = Math.round(rgb1.r + (rgb2.r - rgb1.r) * factor);
                const g = Math.round(rgb1.g + (rgb2.g - rgb1.g) * factor);
                const b = Math.round(rgb1.b + (rgb2.b - rgb1.b) * factor);
                
                return `rgb(${r}, ${g}, ${b})`;
            }

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            }

            rgbToHex(r, g, b) {
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            }

            getInterpolatedPalette(modeName, steps = 10) {
                const mode = this.modeRegistry[modeName];
                if (!mode) return [];

                const interpolated = [];
                const palette = mode.palette;

                for (let i = 0; i < palette.length - 1; i++) {
                    const current = palette[i];
                    const next = palette[i + 1];
                    
                    for (let step = 0; step < steps; step++) {
                        const factor = step / steps;
                        const color = this.interpolateColor(
                            current.color, 
                            next.color, 
                            factor
                        );
                        const alpha = current.alpha + (next.alpha - current.alpha) * factor;
                        
                        interpolated.push({
                            color: color,
                            alpha: alpha,
                            mode: modeName
                        });
                    }
                }

                // Add the final color
                const lastColor = palette[palette.length - 1];
                interpolated.push({
                    color: lastColor.color,
                    alpha: lastColor.alpha,
                    mode: modeName
                });

                return interpolated;
            }

            getRandomColorFromMode(modeName) {
                const mode = this.modeRegistry[modeName];
                if (!mode) return '#ffffff';
                
                const palette = mode.palette;
                const randomIndex = Math.floor(Math.random() * palette.length);
                return palette[randomIndex].color;
            }

            switchEffectMode(modeName) {
                if (!this.modeRegistry[modeName]) return;

                this.currentMode = modeName;
                const mode = this.modeRegistry[modeName];
                
                // Update config
                this.config.artistic.effectMode = modeName;
                
                // Apply mode-specific settings
                this.ctx.globalCompositeOperation = mode.globalComposite;
                
                // Update background theme for this mode if it doesn't override user choice
                if (mode.backgroundTheme) {
                    // Only update if the user hasn't manually set a theme
                    const themeButtons = document.querySelectorAll('[data-theme]');
                    const activeThemeBtn = Array.from(themeButtons).find(btn => 
                        btn.classList.contains('active') && btn.dataset.theme !== mode.backgroundTheme
                    );
                    
                    if (!activeThemeBtn) {
                        this.applyBackgroundTheme(mode.backgroundTheme);
                    }
                    
                    // Apply background pattern if it's set to auto or if pattern matches auto
                    const patternButtons = document.querySelectorAll('[data-pattern]');
                    const activePatternBtn = Array.from(patternButtons).find(btn => btn.classList.contains('active'));
                    
                    if (!activePatternBtn || activePatternBtn.dataset.pattern === 'auto') {
                        if (mode.backgroundPattern) {
                            this.applyBackgroundPattern(mode.backgroundPattern);
                        }
                    }
                }

                // Visual indicator update will be handled by settings panel
                this.updateActiveModeIndicator();
            }

            applyBackgroundPattern(patternType) {
                switch (patternType) {
                    case 'electric-grid':
                        // Dark background with subtle grid lines
                        document.body.style.background = `
                            linear-gradient(135deg, #0a0a0a 0%, #1a0a2e 50%, #16213e 100%),
                            radial-gradient(circle at 25% 25%, rgba(0, 255, 255, 0.1) 0%, transparent 50%),
                            radial-gradient(circle at 75% 75%, rgba(255, 0, 128, 0.1) 0%, transparent 50%)
                        `;
                        break;
                    case 'soft-dots':
                        // Dark background with subtle dot pattern
                        document.body.style.background = `
                            linear-gradient(135deg, #1e1e2e 0%, #2d1b3d 100%),
                            radial-gradient(circle at 1px 1px, rgba(255, 255, 255, 0.05) 1px, transparent 0)
                        `;
                        document.body.style.backgroundSize = '20px 20px, 20px 20px';
                        break;
                    case 'starfield':
                        // Deep space background
                        document.body.style.background = `
                            radial-gradient(2px 2px at 20px 30px, #eee, transparent),
                            radial-gradient(2px 2px at 40px 70px, rgba(255, 255, 255, 0.8), transparent),
                            radial-gradient(1px 1px at 90px 40px, #fff, transparent),
                            radial-gradient(1px 1px at 130px 80px, rgba(255, 255, 255, 0.6), transparent),
                            radial-gradient(2px 2px at 160px 30px, #ddd, transparent),
                            linear-gradient(135deg, #0f0f23 0%, #1a1a3a 50%, #2d1b3d 100%)
                        `;
                        document.body.style.backgroundSize = '200px 100px, 300px 200px, 250px 150px, 180px 120px, 220px 140px, 100% 100%';
                        break;
                    case 'paper-texture':
                        // Light paper-like background
                        document.body.style.background = `
                            radial-gradient(circle at 25% 25%, rgba(0, 0, 0, 0.02) 0%, transparent 50%),
                            radial-gradient(circle at 75% 75%, rgba(0, 0, 0, 0.02) 0%, transparent 50%),
                            linear-gradient(135deg, #f5f5f0 0%, #f0f0e8 100%)
                        `;
                        break;
                    case 'clean':
                    default:
                        // Clean light background
                        document.body.style.background = 'linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%)';
                        break;
                }
            }

            updateActiveModeIndicator() {
                // Update settings panel to show current mode
                const effectButtons = document.querySelectorAll('[data-effect]');
                effectButtons.forEach(btn => {
                    const isActive = btn.dataset.effect === this.currentMode;
                    btn.classList.toggle('active', isActive);
                    btn.setAttribute('aria-pressed', isActive);
                });

                // Update mode description in effect mode section
                const mode = this.modeRegistry[this.currentMode];
                if (mode) {
                    // Update description in the effect mode section
                    const descElement = document.getElementById('modeDescription');
                    if (descElement) {
                        descElement.textContent = mode.description;
                    }

                    // Update header mode indicator
                    const modeColor = document.getElementById('modeColor');
                    const modeName = document.getElementById('modeName');
                    const modeDesc = document.getElementById('modeDesc');

                    if (modeColor && modeName && modeDesc) {
                        modeColor.style.backgroundColor = mode.palette[0].color;
                        modeColor.style.boxShadow = `0 0 8px ${mode.palette[0].color}`;
                        modeName.textContent = mode.name;
                        modeDesc.textContent = mode.description;
                    }
                }
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }

            setupEventListeners() {
                window.addEventListener('resize', () => this.resizeCanvas());
                
                // Create debounced state capture for history
                this.debouncedCaptureState = debounce(() => {
                    this.captureState();
                }, 500);
                
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.mouse.x = e.clientX - rect.left;
                    this.mouse.y = e.clientY - rect.top;
                    this.mouse.isMoving = true;
                    
                    const dx = this.mouse.x - this.mouse.lastX;
                    const dy = this.mouse.y - this.mouse.lastY;
                    const speed = Math.sqrt(dx * dx + dy * dy) * this.config.interaction.speedSensitivity;
                    
                    const brushIntensity = this.config.interaction.brushIntensity;
                    const particleCount = Math.min(Math.floor(speed / 10 * brushIntensity), 10);
                    for (let i = 0; i < particleCount; i++) {
                        this.spawnParticle(speed);
                    }
                    
                    this.createShadowTrail(dx, dy, speed);
                    
                    this.mouse.lastX = this.mouse.x;
                    this.mouse.lastY = this.mouse.y;
                    
                    // Capture state periodically during drawing
                    this.debouncedCaptureState();
                });

                this.canvas.addEventListener('mouseleave', () => {
                    this.mouse.isMoving = false;
                });
            }

            setupControls() {
                document.getElementById('saveBtn').addEventListener('click', () => {
                    this.saveArtwork();
                });

                document.getElementById('clearBtn').addEventListener('click', () => {
                    this.clearCanvas();
                });

                // Settings panel clear button
                const clearSettingsBtn = document.getElementById('clearSettingsBtn');
                if (clearSettingsBtn) {
                    clearSettingsBtn.addEventListener('click', () => {
                        this.clearCanvas();
                    });
                }

                // Undo/Redo buttons
                const undoBtn = document.getElementById('undoBtn');
                const redoBtn = document.getElementById('redoBtn');
                
                if (undoBtn) {
                    undoBtn.addEventListener('click', () => this.undo());
                }
                if (redoBtn) {
                    redoBtn.addEventListener('click', () => this.redo());
                }

                // Keyboard shortcuts
                this.setupKeyboardShortcuts();
            }

            setupKeyboardShortcuts() {
                // Create debounced brush size adjustment
                const debouncedBrushAdjust = debounce((delta) => {
                    const brushSizeEl = document.getElementById('brushSize');
                    const currentValue = parseFloat(brushSizeEl.value);
                    const newValue = Math.max(1, Math.min(20, currentValue + delta));
                    brushSizeEl.value = newValue;
                    this.config.interaction.brushSize = newValue;
                    document.getElementById('brushSizeValue').textContent = newValue;
                }, 50);

                document.addEventListener('keydown', (e) => {
                    const settingsPanel = document.getElementById('settingsPanel');
                    const isSettingsOpen = settingsPanel.classList.contains('open');

                    // Toggle keyboard hints with '?'
                    if (e.key === '?') {
                        e.preventDefault();
                        const hintsPanel = document.getElementById('keyboardHints');
                        hintsPanel.classList.toggle('show');
                        return;
                    }

                    // Don't process shortcuts if settings panel is focused on text input
                    const target = e.target;
                    const isTextInput = target.tagName === 'INPUT' && (target.type === 'text' || target.type === 'color' || target.type === 'range');
                    if (isTextInput) {
                        return;
                    }

                    switch (e.key.toLowerCase()) {
                        case 's':
                            if (e.ctrlKey || e.metaKey) return; // Don't override browser save
                            e.preventDefault();
                            this.saveArtwork();
                            break;

                        case 'c':
                            if (e.ctrlKey || e.metaKey) return; // Don't override browser copy
                            e.preventDefault();
                            this.clearCanvas();
                            break;

                        case 'z':
                            if (!(e.ctrlKey || e.metaKey)) return; // Use OS shortcut
                            e.preventDefault();
                            this.undo();
                            break;

                        case 'r':
                            if (!(e.ctrlKey || e.metaKey)) return; // Use OS shortcut
                            e.preventDefault();
                            this.redo();
                            break;

                        case '+':
                        case '=':
                            e.preventDefault();
                            debouncedBrushAdjust(1);
                            break;

                        case '-':
                        case '_':
                            e.preventDefault();
                            debouncedBrushAdjust(-1);
                            break;

                        default:
                            break;
                    }
                });
            }

            setupSettingsPanel() {
                const settingsBtn = document.getElementById('settingsBtn');
                const settingsPanel = document.getElementById('settingsPanel');
                const settingsOverlay = document.getElementById('settingsOverlay');
                const closeBtn = document.querySelector('.settings-close');

                const togglePanel = () => {
                    settingsPanel.classList.toggle('open');
                    settingsOverlay.classList.toggle('open');
                };

                settingsBtn.addEventListener('click', togglePanel);
                closeBtn.addEventListener('click', togglePanel);
                settingsOverlay.addEventListener('click', togglePanel);

                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && settingsPanel.classList.contains('open')) {
                        togglePanel();
                    }
                });

                this.setupVisualControls();
                this.setupInteractionControls();
                this.setupArtisticControls();
                this.setupPerformanceControls();
            }

            setupVisualControls() {
                const shadowColor = document.getElementById('shadowColor');
                const gradientPrimary = document.getElementById('gradientPrimary');
                const particleColor = document.getElementById('particleColor');

                shadowColor.addEventListener('input', (e) => {
                    this.config.visual.shadowColor = e.target.value;
                    document.getElementById('shadowColorValue').textContent = e.target.value;
                });

                gradientPrimary.addEventListener('input', (e) => {
                    this.config.visual.gradientPrimary = e.target.value;
                    document.getElementById('gradientPrimaryValue').textContent = e.target.value;
                });

                particleColor.addEventListener('input', (e) => {
                    this.config.visual.particleColor = e.target.value;
                    document.getElementById('particleColorValue').textContent = e.target.value;
                });

                const themeButtons = document.querySelectorAll('[data-theme]');
                themeButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        themeButtons.forEach(b => {
                            b.classList.remove('active');
                            b.setAttribute('aria-pressed', 'false');
                        });
                        btn.classList.add('active');
                        btn.setAttribute('aria-pressed', 'true');
                        this.config.visual.backgroundTheme = btn.dataset.theme;
                        this.applyBackgroundTheme(btn.dataset.theme);
                    });
                });

                const patternButtons = document.querySelectorAll('[data-pattern]');
                patternButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        patternButtons.forEach(b => {
                            b.classList.remove('active');
                            b.setAttribute('aria-pressed', 'false');
                        });
                        btn.classList.add('active');
                        btn.setAttribute('aria-pressed', 'true');
                        this.config.visual.backgroundPattern = btn.dataset.pattern;
                        this.applyBackgroundPattern(this.config.visual.backgroundPattern === 'auto' 
                            ? this.modeRegistry[this.currentMode].backgroundPattern 
                            : this.config.visual.backgroundPattern);
                    });
                });
            }

            setupInteractionControls() {
                const brushSize = document.getElementById('brushSize');
                const brushIntensity = document.getElementById('brushIntensity');
                const speedSensitivity = document.getElementById('speedSensitivity');

                brushSize.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    this.config.interaction.brushSize = value;
                    document.getElementById('brushSizeValue').textContent = value;
                });

                brushIntensity.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value).toFixed(1);
                    this.config.interaction.brushIntensity = parseFloat(value);
                    document.getElementById('brushIntensityValue').textContent = value;
                });

                speedSensitivity.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value).toFixed(1);
                    this.config.interaction.speedSensitivity = parseFloat(value);
                    document.getElementById('speedSensitivityValue').textContent = value + 'x';
                });
            }

            setupArtisticControls() {
                const blur = document.getElementById('blur');
                const motion = document.getElementById('motion');
                const opacity = document.getElementById('opacity');
                const persistence = document.getElementById('persistence');

                blur.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    this.config.artistic.blur = value;
                    document.getElementById('blurValue').textContent = value;
                });

                motion.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value).toFixed(2);
                    this.config.artistic.motion = parseFloat(value);
                    document.getElementById('motionValue').textContent = value;
                });

                opacity.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value).toFixed(1);
                    this.config.artistic.opacity = parseFloat(value);
                    document.getElementById('opacityValue').textContent = value;
                });

                persistence.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value).toFixed(2);
                    this.config.artistic.persistence = parseFloat(value);
                    document.getElementById('persistenceValue').textContent = value;
                });

                const effectButtons = document.querySelectorAll('[data-effect]');
                effectButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        const newMode = btn.dataset.effect;
                        if (newMode !== this.currentMode) {
                            // Switch to new effect mode
                            this.switchEffectMode(newMode);
                        }
                    });
                });

                const shapeButtons = document.querySelectorAll('[data-shape]');
                shapeButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        shapeButtons.forEach(b => {
                            b.classList.remove('active');
                            b.setAttribute('aria-pressed', 'false');
                        });
                        btn.classList.add('active');
                        btn.setAttribute('aria-pressed', 'true');
                        this.config.artistic.particleShape = btn.dataset.shape;
                    });
                });
            }

            setupPerformanceControls() {
                const enableParticles = document.getElementById('enableParticles');
                const enableShadows = document.getElementById('enableShadows');
                const enableGlow = document.getElementById('enableGlow');
                const maxParticles = document.getElementById('maxParticles');

                enableParticles.addEventListener('change', (e) => {
                    this.config.performance.enableParticles = e.target.checked;
                });

                enableShadows.addEventListener('change', (e) => {
                    this.config.performance.enableShadows = e.target.checked;
                });

                enableGlow.addEventListener('change', (e) => {
                    this.config.performance.enableGlow = e.target.checked;
                });

                maxParticles.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    this.config.performance.maxParticles = value;
                    document.getElementById('maxParticlesValue').textContent = value;
                });
            }

            applyBackgroundTheme(theme) {
                if (theme === 'light') {
                    document.body.style.background = 'linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%)';
                    this.canvas.style.background = '#ffffff';
                } else {
                    document.body.style.background = 'linear-gradient(135deg, #1e1e2e 0%, #2d1b3d 100%)';
                    this.canvas.style.background = '#0a0a0a';
                }
            }

            spawnParticle(speed) {
                if (!this.config.performance.enableParticles) return;

                const mode = this.modeRegistry[this.currentMode];
                const baseSize = this.config.interaction.brushSize;
                
                // Use mode-specific particle behavior
                const particleBehavior = mode.particleBehavior;
                const particleColor = this.getRandomColorFromMode(this.currentMode);
                
                const particle = {
                    x: this.mouse.x + (Math.random() - 0.5) * 20 * particleBehavior.spreadFactor,
                    y: this.mouse.y + (Math.random() - 0.5) * 20 * particleBehavior.spreadFactor,
                    vx: (Math.random() - 0.5) * speed * 0.1 * this.config.interaction.speedSensitivity,
                    vy: (Math.random() - 0.5) * speed * 0.1 * this.config.interaction.speedSensitivity - 2,
                    gravity: 0.3,
                    friction: this.config.artistic.motion,
                    life: 1.0,
                    maxLife: (60 + Math.random() * 60) * particleBehavior.lifeMultiplier,
                    size: (baseSize + Math.random() * baseSize) * particleBehavior.sizeMultiplier,
                    color: particleColor,
                    alpha: this.config.artistic.opacity * particleBehavior.glowIntensity,
                    shape: this.config.artistic.particleShape,
                    glowIntensity: particleBehavior.glowIntensity,
                    mode: this.currentMode
                };
                
                this.particles.push(particle);
                
                const maxCount = this.config.performance.maxParticles;
                if (this.particles.length > maxCount) {
                    this.particles.splice(0, this.particles.length - maxCount);
                }
            }

            createShadowTrail(dx, dy, speed) {
                if (!this.config.performance.enableShadows) return;

                const mode = this.modeRegistry[this.currentMode];
                const shadowBehavior = mode.shadowBehavior;
                
                // Use mode-specific shadow behavior with enhanced color from mode palette
                const shadowColor = this.getRandomColorFromMode(this.currentMode);
                
                const shadow = {
                    x: this.mouse.x,
                    y: this.mouse.y,
                    opacity: Math.min(speed / 50, 1) * this.config.artistic.opacity * shadowBehavior.opacityMultiplier,
                    blur: Math.min(speed / 10, this.config.artistic.blur) * shadowBehavior.blurMultiplier,
                    radius: Math.max(5, speed / 5) * shadowBehavior.radiusMultiplier,
                    color: shadowColor,
                    life: 1.0,
                    decay: this.config.artistic.motion,
                    shadowMode: this.currentMode,
                    colorIntensity: shadowBehavior.colorIntensity
                };
                
                this.shadows.push(shadow);
                
                const maxShadows = Math.floor(this.config.performance.maxParticles / 2);
                if (this.shadows.length > maxShadows) {
                    this.shadows.splice(0, this.shadows.length - maxShadows);
                }
            }

            getRandomColor() {
                const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#ffeaa7', '#dda0dd'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            getDynamicColor() {
                // Create dynamic color based on mouse position
                const hue = (this.mouse.x + this.mouse.y) / 20;
                return `hsl(${hue % 360}, 70%, 60%)`;
            }

            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    
                    // Update physics
                    particle.vx *= particle.friction;
                    particle.vy *= particle.friction;
                    particle.vy += particle.gravity;
                    
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    
                    // Update life
                    particle.life--;
                    particle.alpha = particle.life / particle.maxLife;
                    
                    // Remove dead particles
                    if (particle.life <= 0 || particle.alpha <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
            }

            updateShadows() {
                for (let i = this.shadows.length - 1; i >= 0; i--) {
                    const shadow = this.shadows[i];
                    
                    shadow.opacity *= shadow.decay;
                    shadow.blur *= 0.99;
                    shadow.radius *= 0.98;
                    
                    // Remove faded shadows
                    if (shadow.opacity <= 0.01) {
                        this.shadows.splice(i, 1);
                    }
                }
            }

            render() {
                const trailAlpha = this.config.artistic.persistence;
                const bgColor = this.config.visual.backgroundTheme === 'light'
                    ? `rgba(255, 255, 255, ${trailAlpha})`
                    : `rgba(10, 10, 10, ${trailAlpha})`;
                
                this.ctx.fillStyle = bgColor;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                if (this.config.performance.enableShadows) {
                    this.renderShadows();
                }
                
                if (this.config.performance.enableParticles) {
                    this.renderParticles();
                }
                
                if (this.config.performance.enableGlow && this.mouse.isMoving) {
                    this.renderCursorGlow();
                }
            }

            renderShadows() {
                this.shadows.forEach(shadow => {
                    this.ctx.save();
                    
                    // Apply mode-specific blending and effects
                    const mode = this.modeRegistry[shadow.shadowMode];
                    if (mode) {
                        this.ctx.globalCompositeOperation = mode.blendingMode;
                    }
                    
                    this.ctx.globalAlpha = shadow.opacity;
                    this.ctx.filter = `blur(${shadow.blur}px)`;
                    
                    // Apply mode-specific color effects
                    let renderColor = shadow.color;
                    if (shadow.colorIntensity !== undefined) {
                        const rgb = this.hexToRgb(shadow.color);
                        if (rgb) {
                            // Apply intensity multiplier
                            const intensity = shadow.colorIntensity;
                            renderColor = `rgb(${Math.min(255, rgb.r * intensity)}, ${Math.min(255, rgb.g * intensity)}, ${Math.min(255, rgb.b * intensity)})`;
                        }
                    }
                    
                    this.ctx.fillStyle = renderColor;
                    
                    this.ctx.beginPath();
                    this.ctx.arc(shadow.x, shadow.y, shadow.radius, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                });
            }

            renderParticles() {
                this.particles.forEach(particle => {
                    this.ctx.save();
                    
                    // Apply mode-specific blending
                    const mode = this.modeRegistry[particle.mode];
                    if (mode) {
                        this.ctx.globalCompositeOperation = mode.blendingMode;
                    }
                    
                    const alpha = particle.alpha * (particle.life / particle.maxLife);
                    this.ctx.globalAlpha = alpha;
                    
                    if (particle.shape === 'square') {
                        this.ctx.fillStyle = particle.color;
                        this.ctx.fillRect(
                            particle.x - particle.size / 2,
                            particle.y - particle.size / 2,
                            particle.size,
                            particle.size
                        );
                    } else {
                        // Create mode-specific gradients
                        let gradient;
                        
                        if (this.currentMode === 'neon') {
                            // Enhanced glow for neon mode
                            const glowSize = particle.size * 2;
                            gradient = this.ctx.createRadialGradient(
                                particle.x, particle.y, 0,
                                particle.x, particle.y, glowSize
                            );
                            gradient.addColorStop(0, particle.color);
                            gradient.addColorStop(0.3, particle.color);
                            gradient.addColorStop(0.7, 'transparent');
                            gradient.addColorStop(1, 'transparent');
                        } else if (this.currentMode === 'lightTrails') {
                            // Motion blur effect
                            gradient = this.ctx.createLinearGradient(
                                particle.x - particle.size * 2, particle.y,
                                particle.x + particle.size * 2, particle.y
                            );
                            gradient.addColorStop(0, 'transparent');
                            gradient.addColorStop(0.5, particle.color);
                            gradient.addColorStop(1, 'transparent');
                        } else if (this.currentMode === 'inkEffect') {
                            // Diffused ink effect
                            const inkSize = particle.size * 1.5;
                            gradient = this.ctx.createRadialGradient(
                                particle.x, particle.y, 0,
                                particle.x, particle.y, inkSize
                            );
                            gradient.addColorStop(0, particle.color);
                            gradient.addColorStop(0.4, particle.color);
                            gradient.addColorStop(0.8, 'rgba(0, 0, 0, 0.3)');
                            gradient.addColorStop(1, 'transparent');
                        } else {
                            // Standard gradient for other modes
                            gradient = this.ctx.createRadialGradient(
                                particle.x, particle.y, 0,
                                particle.x, particle.y, particle.size
                            );
                            gradient.addColorStop(0, particle.color);
                            gradient.addColorStop(1, 'transparent');
                        }
                        
                        this.ctx.fillStyle = gradient;
                        this.ctx.beginPath();
                        this.ctx.arc(particle.x, particle.y, particle.size * (particle.glowIntensity || 1), 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    this.ctx.restore();
                });
            }

            renderCursorGlow() {
                const gradient = this.ctx.createRadialGradient(
                    this.mouse.x, this.mouse.y, 0,
                    this.mouse.x, this.mouse.y, 30
                );
                
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
                gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.1)');
                gradient.addColorStop(1, 'transparent');
                
                this.ctx.save();
                this.ctx.globalAlpha = 0.6;
                this.ctx.fillStyle = gradient;
                this.ctx.beginPath();
                this.ctx.arc(this.mouse.x, this.mouse.y, 30, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
            }

            clearCanvas() {
                this.ctx.fillStyle = this.config.visual.backgroundTheme === 'light' ? '#ffffff' : '#0a0a0a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.particles = [];
                this.shadows = [];
                this.captureState();
            }

            saveArtwork() {
                // Create a temporary link and trigger download
                const link = document.createElement('a');
                link.download = `shadow-painter-artwork-${Date.now()}.png`;
                link.href = this.canvas.toDataURL();
                link.click();
            }

            updateFPS(currentTime) {
                if (currentTime - this.fpsUpdateTime >= 1000) {
                    const deltaTime = currentTime - this.lastTime;
                    this.fps = Math.round(1000 / deltaTime);
                    document.getElementById('fps').textContent = `FPS: ${this.fps}`;
                    this.fpsUpdateTime = currentTime;
                }
            }

            animate(currentTime = 0) {
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;

                this.updateParticles();
                this.updateShadows();
                this.render();
                this.updateFPS(currentTime);

                requestAnimationFrame((time) => this.animate(time));
            }
        }

        // Initialize the application when the page loads
        window.addEventListener('load', () => {
            new ShadowPainter();
        });
    </script>
</body>
</html>